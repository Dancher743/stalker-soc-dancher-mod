--
-- Artefacts Respawn Mod
-- Автор: Bak
-- Изменил: Dancher
--

local excluded_levels = {
	l05_bar = true,
	-- исключаем подземные уровни, там не надо арты спавнить
	l03u_agr_underground = true,
	l08u_brainlab = true, 
	l10u_bunker = true,
	l04u_labx18 = true,
	l12u_sarcofag = true,
	l12u_control_monolith = true
}

--' Обновление аномалий для рождения артефактов.
--' Перебираются все аномалии на всех уровнях, по одной за апдейт.
--' Время между апдейтами устанавливается в next_update_time_delta.

local next_update_time = 0
local next_update_time_delta = 5000 -- 5 секунд.
local registered_anoms = {}
local is_anom_gave_birth = false

function update_anoms(time)
	if time <= next_update_time then
		return
	end
	
	if not excluded_levels[level.name()] then
		for i,anom in pairs(registered_anoms) do
			if anom then
				try_to_born(anom)
			end
		end
	end
	
	if is_anom_gave_birth and 
		pda_upgrade_manager.has_upgrade(3)
	then
		pda_upgrade_manager.use_upgrade(3, nil)
	end
	
	next_update_time = time + next_update_time_delta
	is_anom_gave_birth = false
end

function update_anoms_after_surge()	
	if not excluded_levels[level.name()] then
		for i,anom in pairs(registered_anoms) do
			if anom then
				try_to_born_immediately(anom)
			end
		end
	end
	
	--[[if is_anom_gave_birth and 
		pda_upgrade_manager.has_upgrade(3)
	then
		pda_upgrade_manager.use_upgrade(3, nil)
	end]]--
	
	is_anom_gave_birth = false
end

function try_to_born(anom)
	if anom.last_spawn_time == nil then
		anom.last_spawn_time = game.get_game_time()
		return
	end
	if game.get_game_time():diffSec(anom.last_spawn_time) >= anom.artefact_spawn_idle then
		try_to_born_immediately(anom)
	end
end

function try_to_born_immediately(anom)
	anom.last_spawn_time = game.get_game_time()
	if math.random(100) <= anom.artefact_spawn_rnd then
		anom:spawn_artefacts()
		is_anom_gave_birth = true
	end
end

--. Разродить все аномалии в игре, или на определённом уровне
function all_born_artefacts(loc)
	if loc == "current" then
		loc = level.name()
	end
	local gg = game_graph()
	for i,a in pairs(registered_anoms) do
		if a.m_game_vertex_id and gg:valid_vertex_id(a.m_game_vertex_id) then
			if not loc or loc == "all" or loc == alife():level_name(gg:vertex(a.m_game_vertex_id):level_id()) then
				try_to_born_immediately(a)
			end
		end
	end
end

function is_single_player_game	()
	if (_G.alife == nil) then
		return	(true)
	end

	if (alife() ~= nil) then
		return	(true)
	end

	if (_G.IsGameTypeSingle == nil) then
		return	(true)
	end

	if (IsGameTypeSingle() == true) then
		return	(true)
	end

	return		(false)
end

class "se_zone_anom" (cse_anomalous_zone)
function se_zone_anom:__init (section) super (section)
end
function se_zone_anom:on_register()
	cse_anomalous_zone.on_register(self)

	self.artefact_spawn_idle = 60*60*utils.cfg_get_number(system_ini(), self:section_name(), "artefact_spawn_idle", self, false, 24)
	self.artefact_spawn_rnd = utils.cfg_get_number(system_ini(), self:section_name(), "artefact_spawn_rnd", self, false, 100)
	self.ri = #registered_anoms+1
	registered_anoms[self.ri] = self
end
function se_zone_anom:on_unregister()
	cse_anomalous_zone.on_unregister(self)
	registered_anoms[self.ri] = nil
end
function se_zone_anom:update()
	cse_anomalous_zone.update(self)
end
function se_zone_anom:STATE_Write(packet)
	cse_anomalous_zone.STATE_Write(self, packet)

	if (is_single_player_game() == false) then
		return
	end

	if self.last_spawn_time == nil then
		packet:w_u8(0)
	else
		packet:w_u8(1)
		utils.w_CTime(packet, self.last_spawn_time)
	end
end
-- восстановление
function se_zone_anom:STATE_Read( packet, size )
	cse_anomalous_zone.STATE_Read( self, packet, size )

	if self.id~=65535 then
        anomaly_holder.add_anomaly(self.id,self:clsid())
    end

	if editor() then
		return
	end

	if (is_single_player_game() == false) then
		return
	end

	local flag = packet:r_u8()
	if flag == 1 then
		self.last_spawn_time = utils.r_CTime(packet)
	end
end


class "se_zone_visual" (cse_zone_visual)
function se_zone_visual:__init (section) super (section)
end
function se_zone_visual:on_register()
	cse_zone_visual.on_register(self)

	self.artefact_spawn_idle = 60*60*utils.cfg_get_number(system_ini(), self:section_name(), "artefact_spawn_idle", self, false, 24)
	self.artefact_spawn_rnd = utils.cfg_get_number(system_ini(), self:section_name(), "artefact_spawn_rnd", self, false, 100)
	
	self.ri = #registered_anoms+1
	registered_anoms[self.ri] = self
end
function se_zone_visual:on_unregister()
	cse_zone_visual.on_unregister(self)
	anomaly_holder.remove_anomaly(self.id)
	registered_anoms[self.ri] = nil
end
function se_zone_visual:update()
	cse_zone_visual.update(self)
end

function se_zone_visual:STATE_Write(packet)
	cse_zone_visual.STATE_Write(self, packet)

	if (is_single_player_game() == false) then
		return
	end

	if self.last_spawn_time == nil then
		packet:w_u8(0)
	else
		packet:w_u8(1)
		utils.w_CTime(packet, self.last_spawn_time)
	end
end
-- восстановление
function se_zone_visual:STATE_Read( packet, size )
	cse_zone_visual.STATE_Read( self, packet, size )

	if editor() then
		return
	end

	if (is_single_player_game() == false) then
		return
	end

	local flag = packet:r_u8()
	if flag == 1 then
		self.last_spawn_time = utils.r_CTime(packet)
	end
end



--' Рестрикторы
class "se_restrictor" (cse_alife_space_restrictor)
function se_restrictor:__init (section) super (section)
end
function se_restrictor:keep_saved_data_anyway()
	return true
end